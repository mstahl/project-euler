-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
-- all figurate (polygonal) numbers and are generated by the following formulae:
-- 
-- Triangle       P_(3,n)=n(n+1)/2      1, 3, 6, 10, 15, ...
-- Square         P_(4,n)=n^(2)         1, 4, 9, 16, 25, ...
-- Pentagonal     P_(5,n)=n(3n−1)/2     1, 5, 12, 22, 35, ...
-- Hexagonal      P_(6,n)=n(2n−1)       1, 6, 15, 28, 45, ...
-- Heptagonal     P_(7,n)=n(5n−3)/2     1, 7, 18, 34, 55, ...
-- Octagonal      P_(8,n)=n(3n−2)       1, 8, 21, 40, 65, ...
-- 
-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
-- interesting properties.
--   1. The set is cyclic, in that the last two digits of each number is the first
-- two digits of the next number (including the last number with the first).
--   2. Each polygonal type: triangle (P_(3,127)=8128), square (P_(4,91)=8281), and
-- pentagonal (P_(5,44)=2882), is represented by a different number in the set.
--   3. This is the only set of 4-digit numbers with this property.
-- Find the sum of the only ordered set of six cyclic 4-digit numbers for which
-- each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
-- octagonal, is represented by a different number in the set.
-- 
-- http://projecteuler.net/index.php?section=problems&id=61

module Main where

import Data.List (nub, (\\))

triangles = takeWhile (<10000) $ dropWhile (<1000) $ [n * (n + 1) `div` 2 | n <- [1..]]
squares =   takeWhile (<10000) $ dropWhile (<1000) $ [n ^ 2 | n <- [1..]]
pentagons = takeWhile (<10000) $ dropWhile (<1000) $ [n * (3 * n - 1) `div` 2 | n <- [1..]]
hexagons =  takeWhile (<10000) $ dropWhile (<1000) $ [n * (2 * n - 1) | n <- [1..]]
heptagons = takeWhile (<10000) $ dropWhile (<1000) $ [n * (5 * n - 3) `div` 2 | n <- [1..]]
octagons =  takeWhile (<10000) $ dropWhile (<1000) $ [n * (3 * n - 2) | n <- [1..]]

begins_with :: Integral t => t -> t -> Bool
begins_with xx xxxx = xxxx `div` 100 == xx

ends_with :: Integral t => t -> t -> Bool
ends_with xx xxxx = xxxx `mod` 100 == xx

figurates = [ (a, b, c, d, e, f) 
            | a <- octagons
            , b <- filter (ends_with (a `div` 100)) triangles
            , c <- filter (ends_with (b `div` 100)) hexagons
            , d <- filter (ends_with (c `div` 100)) pentagons
            , e <- filter (ends_with (d `div` 100)) heptagons
            , f <- filter (ends_with (e `div` 100)) squares
            ]

test_figurate = [(a, b, c, d, e, f) | a <- octagons
                                    , b <- filter (begins_with (a `mod` 100)) triangles
                                    , c <- filter (begins_with (a `mod` 100)) hexagons
                                    , d <- filter (begins_with (a `mod` 100)) pentagons
                                    , e <- filter (begins_with (a `mod` 100)) heptagons
                                    , f <- filter (begins_with (a `mod` 100)) squares
                                    ]

set :: Integral t => (t, t, t, t, t, t) -> Bool
set (a, b, c, d, e, f) = 
  let inits = map (\x -> x `div` 100) [a, b, c, d, e, f]
      tails = map (\x -> x `mod` 100) [a, b, c, d, e, f]
  in inits \\ tails == []

main :: IO ()
main = do putStrLn $ "There are " ++ (show $ length $ octagons ) ++ " octagonal numbers"
          putStrLn $ "There are " ++ (show $ length $ heptagons) ++ " heptagonal numbers"
          putStrLn $ "There are " ++ (show $ length $ hexagons ) ++ " hexagonal numbers"
          putStrLn $ "There are " ++ (show $ length $ pentagons) ++ " pentagonal numbers"
          putStrLn $ "There are " ++ (show $ length $ squares  ) ++ " square numbers"
          putStrLn $ "There are " ++ (show $ length $ triangles) ++ " triangle numbers"
          print $ filter (\x -> (set x)) figurates

