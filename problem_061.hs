-- Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
-- all figurate (polygonal) numbers and are generated by the following formulae:
-- 
-- Triangle       P_(3,n)=n(n+1)/2      1, 3, 6, 10, 15, ...
-- Square         P_(4,n)=n^(2)         1, 4, 9, 16, 25, ...
-- Pentagonal     P_(5,n)=n(3n−1)/2     1, 5, 12, 22, 35, ...
-- Hexagonal      P_(6,n)=n(2n−1)       1, 6, 15, 28, 45, ...
-- Heptagonal     P_(7,n)=n(5n−3)/2     1, 7, 18, 34, 55, ...
-- Octagonal      P_(8,n)=n(3n−2)       1, 8, 21, 40, 65, ...
-- 
-- The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
-- interesting properties.
--   1. The set is cyclic, in that the last two digits of each number is the first
-- two digits of the next number (including the last number with the first).
--   2. Each polygonal type: triangle (P_(3,127)=8128), square (P_(4,91)=8281), and
-- pentagonal (P_(5,44)=2882), is represented by a different number in the set.
--   3. This is the only set of 4-digit numbers with this property.
-- Find the sum of the only ordered set of six cyclic 4-digit numbers for which
-- each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
-- octagonal, is represented by a different number in the set.
-- 
-- http://projecteuler.net/index.php?section=problems&id=61

module Main where

import Data.List (nub, (\\))

triangles = takeWhile (<10000) $ drop 44 [n * (n + 1) `div` 2 | n <- [1..]]
squares =   takeWhile (<10000) $ drop 31 [n ^ 2 | n <- [1..]]
pentagons = takeWhile (<10000) $ drop 25 [n * (3 * n - 1) `div` 2 | n <- [1..]]
hexagons =  takeWhile (<10000) $ drop 22 [n * (2 * n - 1) | n <- [1..]]
heptagons = takeWhile (<10000) $ drop 20 [n * (5 * n - 3) `div` 2 | n <- [1..]]
octagons =  takeWhile (<10000) $ drop 18 [n * (3 * n - 2) | n <- [1..]]

-- This method breaks the numbers in the 6-tuple into two-digit chunks then
-- counts the number of unique ones. If six numbers are cyclical, each pair
-- should be repeated twice, once on one number and again on the next. So,
-- if a given set of 4-digit numbers is cyclical, there should be as many
-- unique 2-digit chunks as there are numbers.
inits = map (\x -> x `div` 100)
tails = map (\x -> x `mod` 100)
set (a, b, c, d, e, f) = 
  (inits [a,b,c,d,e,f]) \\ (tails [a,b,c,d,e,f]) == []

answers = [(tr, sq, pe, hx, hp, oc) | tr <- triangles
                                    , sq <- squares
                                    , pe <- pentagons
                                    , hx <- hexagons
                                    , hp <- heptagons
                                    , oc <- octagons
                                    , set (tr, sq, pe, hx, hp, oc)
                                    ]

main :: IO ()
main = do print $ head $ answers